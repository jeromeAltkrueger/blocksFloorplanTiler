<!DOCTYPE html>
<html>
<head>
    <title>Floorplan Annotation Test</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map {
            position: absolute;
            top: 0;
            bottom: 200px;
            width: 100%;
        }
        #output {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            overflow: auto;
            padding: 10px;
            border-top: 2px solid #007acc;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 15px;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 1000;
            max-width: 300px;
        }
        #controls h3 {
            margin: 0 0 10px 0;
        }
        #controls button {
            margin: 5px 0;
            padding: 8px 12px;
            width: 100%;
            cursor: pointer;
        }
        #controls input {
            width: 100%;
            padding: 5px;
            margin: 5px 0;
            font-family: monospace;
            font-size: 11px;
        }
        .info {
            color: #4CAF50;
        }
        .warning {
            color: #ff9800;
        }
        .error {
            color: #f44336;
        }
        .code {
            background: #2d2d2d;
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid #007acc;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>üìù Annotation Test</h3>
        <div>
            <label>Metadata URL:</label>
            <input type="text" id="metadataUrl" value="https://blocksplayground.blob.core.windows.net/blocks/floorplans/120021/metadata.json">
        </div>
        <button onclick="loadFloorplan()">Load Floorplan</button>
        <div id="status" style="margin-top: 10px; font-size: 11px;"></div>
    </div>
    
    <div id="map"></div>
    <div id="output">
        <div class="info">üëà Load a floorplan, then use the drawing tools to draw rectangles.</div>
        <div class="info">üìã The GeoJSON will appear here automatically.</div>
    </div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script>
        let map, tileLayer, drawnItems, metadata;
        
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const color = type === 'error' ? '#f44336' : type === 'warning' ? '#ff9800' : '#4CAF50';
            output.innerHTML += `<div style="color: ${color}">${message}</div>`;
            output.scrollTop = output.scrollHeight;
        }
        
        function logCode(code) {
            const output = document.getElementById('output');
            output.innerHTML += `<div class="code">${code}</div>`;
            output.scrollTop = output.scrollHeight;
        }
        
        async function loadFloorplan() {
            const metadataUrl = document.getElementById('metadataUrl').value;
            const status = document.getElementById('status');
            
            try {
                status.innerHTML = '<span class="info">Loading...</span>';
                log('üîÑ Loading metadata...', 'info');
                
                const response = await fetch(metadataUrl);
                if (!response.ok) throw new Error('Failed to load metadata');
                
                metadata = await response.json();
                log('‚úÖ Metadata loaded', 'info');
                log(`   Floorplan ID: ${metadata.floorplan_id}`, 'info');
                log(`   Image size: ${metadata.source_image.width} x ${metadata.source_image.height}`, 'info');
                
                // CALCULATE CORRECT LEAFLET BOUNDS
                const tileSize = metadata.tile_size || 512;
                const maxZoom = metadata.max_zoom;
                const scaleFactor = tileSize * Math.pow(2, maxZoom - maxZoom); // = tileSize
                
                const leafletWidth = metadata.source_image.width / scaleFactor;
                const leafletHeight = metadata.source_image.height / scaleFactor;
                
                // Store calculated bounds
                metadata.calculated_bounds = [[0, 0], [leafletHeight, leafletWidth]];
                
                log(`   Calculated Leaflet bounds: [[0, 0], [${leafletHeight.toFixed(2)}, ${leafletWidth.toFixed(2)}]]`, 'info');
                log('   ', 'info');
                log('   ‚ö†Ô∏è  Note: Metadata bounds may be incorrect (in pixels): ' + JSON.stringify(metadata.bounds), 'warning');
                log('   ‚úÖ  Using calculated bounds instead (in Leaflet coordinate space)', 'info');
                
                // Initialize map if not already done
                if (!map) {
                    initMap(metadata);
                } else {
                    updateMap(metadata);
                }
                
                status.innerHTML = '<span class="info">‚úÖ Ready</span>';
                
            } catch (error) {
                log(`‚ùå Error: ${error.message}`, 'error');
                status.innerHTML = `<span class="error">Error: ${error.message}</span>`;
            }
        }
        
        function initMap(metadata) {
            const width = metadata.source_image.width;
            const height = metadata.source_image.height;
            const minZoom = metadata.min_zoom;
            const maxZoom = metadata.max_zoom;
            const tileSize = metadata.tile_size || 512;
            
            // Use calculated bounds (NOT metadata.bounds which may be wrong)
            const bounds = metadata.calculated_bounds;
            const center = [bounds[1][0] / 2, bounds[1][1] / 2]; // [height/2, width/2] in Leaflet space
            
            log('üó∫Ô∏è  Initializing map with L.CRS.Simple', 'info');
            log(`   Bounds: ${JSON.stringify(bounds)}`, 'info');
            log(`   Center: [${center[0].toFixed(2)}, ${center[1].toFixed(2)}]`, 'info');
            log(`   Bounds: ${JSON.stringify(bounds)}`, 'info');
            log(`   Center: [${center[0].toFixed(2)}, ${center[1].toFixed(2)}]`, 'info');
            
            // Initialize map with Simple CRS
            map = L.map('map', {
                crs: L.CRS.Simple,
                minZoom: minZoom,
                maxZoom: maxZoom + 3, // Allow zooming in beyond native tiles
                maxBounds: bounds,
                maxBoundsViscosity: 1.0
            });
            
            map.setView(center, maxZoom);
            
            // Construct tile URL
            const baseUrl = metadata.tile_url_template || `https://blocksplayground.blob.core.windows.net/blocks/floorplans/${metadata.floorplan_id}`;
            const tileUrl = baseUrl.includes('{z}') ? baseUrl : `${baseUrl}/{z}/{x}/{y}.png`;
            
            log(`   Tile URL: ${tileUrl}`, 'info');
            
            // Add tile layer
            tileLayer = L.tileLayer(tileUrl, {
                tileSize: tileSize,
                minNativeZoom: minZoom,
                maxNativeZoom: maxZoom,
                bounds: bounds,
                noWrap: true
            }).addTo(map);
            
            // Initialize drawing tools
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);
            
            const drawControl = new L.Control.Draw({
                draw: {
                    polygon: true,
                    rectangle: true,
                    circle: false,
                    circlemarker: false,
                    marker: true,
                    polyline: false
                },
                edit: {
                    featureGroup: drawnItems,
                    remove: true
                }
            });
            map.addControl(drawControl);
            
            log('‚úÖ Drawing tools enabled', 'info');
            log('', 'info');
            log('üìù Instructions:', 'info');
            log('   1. Use the drawing tools (top-left) to draw rectangles or polygons', 'info');
            log('   2. The GeoJSON coordinates will appear below automatically', 'info');
            log('   3. Copy the entire object array to test with the annotation API', 'info');
            log('', 'info');
            
            // Handle drawing events
            map.on(L.Draw.Event.CREATED, function (event) {
                const layer = event.layer;
                drawnItems.addLayer(layer);
                
                // Get GeoJSON
                const geoJson = layer.toGeoJSON();
                
                log('‚îÅ'.repeat(60), 'info');
                log('‚úèÔ∏è  New shape drawn!', 'info');
                log('', 'info');
                log('üìã Copy this object for the annotation API:', 'info');
                logCode(JSON.stringify(geoJson, null, 2));
                log('', 'info');
                
                // Show coordinate details
                const coords = geoJson.geometry.coordinates;
                if (geoJson.geometry.type === 'Polygon') {
                    log('üìç Polygon coordinates (GeoJSON format [lon, lat]):', 'info');
                    coords[0].forEach((point, i) => {
                        log(`   Point ${i}: [${point[0].toFixed(2)}, ${point[1].toFixed(2)}]`, 'info');
                    });
                } else if (geoJson.geometry.type === 'Point') {
                    log(`üìç Point: [${coords[0].toFixed(2)}, ${coords[1].toFixed(2)}]`, 'info');
                }
                
                log('', 'info');
                log('‚úÖ These coordinates are in the correct format!', 'info');
                log(`   X (longitude) range: 0 to ${bounds[1][1].toFixed(2)}`, 'info');
                log(`   Y (latitude) range: 0 to ${bounds[1][0].toFixed(2)}`, 'info');
                log('‚îÅ'.repeat(60), 'info');
            });
            
            map.on(L.Draw.Event.DELETED, function (event) {
                log('üóëÔ∏è  Shape(s) deleted', 'warning');
            });
        }
        
        function updateMap(metadata) {
            const bounds = metadata.calculated_bounds;
            const center = [bounds[1][0] / 2, bounds[1][1] / 2];
            
            map.setMaxBounds(bounds);
            map.setView(center, map.getZoom());
            
            // Update tile layer
            const baseUrl = `https://blocksplayground.blob.core.windows.net/blocks/floorplans/${metadata.floorplan_id}`;
            const tileUrl = `${baseUrl}/{z}/{x}/{y}.png`;
            
            if (tileLayer) {
                map.removeLayer(tileLayer);
            }
            
            tileLayer = L.tileLayer(tileUrl, {
                tileSize: metadata.tile_size || 512,
                minNativeZoom: metadata.min_zoom,
                maxNativeZoom: metadata.max_zoom,
                bounds: bounds,
                noWrap: true
            }).addTo(map);
            
            log('‚úÖ Map updated with new floorplan', 'info');
        }
        
        // Auto-load on page load
        window.onload = function() {
            log('üöÄ Ready to load floorplan!', 'info');
            log('   Enter a metadata URL and click "Load Floorplan"', 'info');
            log('', 'info');
        };
    </script>
</body>
</html>
